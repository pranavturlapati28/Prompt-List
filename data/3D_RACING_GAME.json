{
  "project": "3D Racing Game",
  "mainRequest": "Build a 3D racing video game in React Three Fiber where the player drives against AI opponents on a pregenerated racing track.",
  "prompts": [
    {
      "id": 1,
      "title": "Project Setup",
      "description": "Initialize the development environment and install all required dependencies.",
      "nodes": [
        {
          "name": "npm create vite",
          "action": "Scaffold a new React project using Vite as the build tool. Select React + TypeScript template for type safety and fast HMR."
        },
        {
          "name": "Install dependencies",
          "action": "Add core 3D libraries: @react-three/fiber for React Three.js bindings, @react-three/drei for helpful abstractions, and @react-three/rapier for physics simulation."
        },
        {
          "name": "Create folder structure",
          "action": "Organize the project into logical directories: components/ for React/3D components, hooks/ for custom hooks, utils/ for helper functions, assets/ for models and textures, and stores/ for game state management."
        }
      ]
    },
    {
      "id": 2,
      "title": "3D Environment",
      "description": "Build the visual atmosphere and world surrounding the race track.",
      "nodes": [
        {
          "name": "HDRI skybox",
          "action": "Load a high dynamic range image as the scene environment using drei's <Environment> component. This provides realistic sky rendering and image-based lighting for reflections on car surfaces."
        },
        {
          "name": "Lighting setup",
          "action": "Configure a directional light to simulate the sun with shadows enabled. Add ambient light for fill. Adjust intensity and shadow map resolution for performance balance."
        },
        {
          "name": "Ground plane",
          "action": "Create a large ground mesh extending beyond the track with a grass or terrain texture. Apply a repeating material and ensure it receives shadows from vehicles and track elements."
        }
      ]
    },
    {
      "id": 3,
      "title": "Racing Track",
      "description": "Generate the prebuilt racing circuit with all necessary geometry and race markers.",
      "nodes": [
        {
          "name": "Track spline",
          "action": "Define a CatmullRomCurve3 path using an array of Vector3 control points that form the racing line. This spline serves as the foundation for track generation and AI navigation."
        },
        {
          "name": "Track mesh",
          "action": "Extrude a road cross-section shape along the spline to create the track surface geometry. Apply asphalt texture with UV mapping that follows the curve. Add the mesh as a physics collider."
        },
        {
          "name": "Barriers",
          "action": "Generate wall meshes along both edges of the track using offset splines. Add RigidBody colliders to prevent cars from leaving the circuit. Style with tire wall or concrete barrier textures."
        },
        {
          "name": "Checkpoints",
          "action": "Create invisible trigger zones at regular intervals around the track using sensor colliders. These track player progress and prevent lap-skipping by requiring sequential checkpoint passage."
        },
        {
          "name": "Start/finish line",
          "action": "Place a visual marker mesh (checkered pattern) at the race origin. Add a dedicated trigger zone that increments lap count when crossed after completing all checkpoints."
        }
      ]
    },
    {
      "id": 4,
      "title": "Player Vehicle",
      "description": "Implement the user-controlled car with physics and camera.",
      "nodes": [
        {
          "name": "Car model",
          "action": "Load a 3D car model (GLTF/GLB format) using useGLTF hook. Ensure the model has separate wheel meshes for rotation animation. Apply materials and set appropriate scale."
        },
        {
          "name": "Vehicle physics",
          "action": "Create a dynamic RigidBody for the car chassis. Implement a raycast vehicle controller with four wheel configurations including suspension stiffness, friction, and roll influence parameters."
        },
        {
          "name": "Keyboard controls",
          "action": "Set up input handling for WASD or arrow keys. Map vertical axis to acceleration/braking force applied to wheels. Map horizontal axis to steering angle with smooth interpolation."
        },
        {
          "name": "Chase camera",
          "action": "Implement a third-person camera that follows behind the player car. Use useFrame to smoothly lerp camera position and look-at target. Add slight lag for dynamic feel during turns."
        }
      ]
    },
    {
      "id": 5,
      "title": "AI Opponents",
      "description": "Create computer-controlled vehicles that race against the player.",
      "nodes": [
        {
          "name": "Spawn AI cars",
          "action": "Instantiate multiple opponent vehicles at staggered starting positions on the grid. Use the same car model with different color materials. Each AI car gets its own RigidBody and state."
        },
        {
          "name": "Pathfinding",
          "action": "Implement spline-following behavior where AI cars steer toward the next waypoint along the track curve. Sample points ahead on the spline and calculate steering angle to reach them."
        },
        {
          "name": "Speed AI",
          "action": "Add randomized speed multipliers to each AI car for varied difficulty. Implement acceleration curves and braking logic when approaching sharp turns based on track curvature analysis."
        },
        {
          "name": "Collision avoidance",
          "action": "Cast rays forward and to sides from each AI car. When obstacles are detected, apply lateral steering adjustments to avoid collisions with walls and other vehicles."
        }
      ]
    },
    {
      "id": 6,
      "title": "Game Systems",
      "description": "Implement core racing game logic and state management.",
      "nodes": [
        {
          "name": "Lap counting",
          "action": "Track each vehicle's checkpoint progress in a state store. When a car crosses the finish line trigger with all checkpoints cleared, increment their lap counter and reset checkpoint flags."
        },
        {
          "name": "Position tracking",
          "action": "Calculate race positions by comparing each car's lap count and progress percentage along the track spline. Update positions in real-time and store for UI display."
        },
        {
          "name": "Race timer",
          "action": "Start a countdown timer at race begin (3-2-1-GO sequence). Track elapsed race time and individual lap times. Store best lap time for display. Pause timer when race ends."
        },
        {
          "name": "Win/lose logic",
          "action": "Define race completion as finishing a set number of laps (e.g., 3). Determine final standings when all cars finish or timeout. Trigger end-race state with results display."
        }
      ]
    },
    {
      "id": 7,
      "title": "UI / HUD",
      "description": "Build the heads-up display and menu interfaces.",
      "nodes": [
        {
          "name": "Speedometer",
          "action": "Create an overlay component displaying current player speed. Calculate from vehicle velocity magnitude. Style as digital readout or analog gauge with needle animation."
        },
        {
          "name": "Position display",
          "action": "Show player's current race position prominently (e.g., '2nd / 4'). Update in real-time as positions change. Add ordinal suffix formatting (1st, 2nd, 3rd)."
        },
        {
          "name": "Lap counter",
          "action": "Display current lap number and total laps (e.g., 'Lap 2 / 3'). Show current lap time and best lap time below. Flash or highlight on new best lap."
        },
        {
          "name": "Mini-map",
          "action": "Render a top-down 2D view of the track in a corner overlay. Show dots for all car positions color-coded by player/AI. Rotate map to match player heading or keep north-up."
        },
        {
          "name": "Menus",
          "action": "Create start screen with race configuration options. Implement pause menu with resume/restart/quit options. Build results screen showing final standings, times, and replay option."
        }
      ]
    }
  ],
  "finalIntegration": "Combine all systems, polish interactions, add particle effects (tire smoke, sparks), implement sound effects (engine, collisions), and optimize performance for smooth 60fps gameplay."
}

